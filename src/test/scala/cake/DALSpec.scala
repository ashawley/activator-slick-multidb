import org.specs2.mutable.Specification
import org.specs2.concurrent.ExecutionEnv
import org.specs2.mutable.After
import org.scalamock.specs2.IsolatedMockFactory
import org.specs2.matcher.ThrownExpectations

import slick.driver.{H2Driver, SQLiteDriver, MySQLDriver}
import slick.jdbc.JdbcBackend.Database
import slick.util.AsyncExecutor
import slick.dbio.DBIO

import java.lang.{String => JString}

import com.typesafe.config.ConfigException

class DALSpec extends Specification with IsolatedMockFactory with After {

  val connection = stub[java.sql.Connection]
  val dataSource = stub[slick.jdbc.JdbcDataSource]
  val preparedStatement = stub[java.sql.PreparedStatement]

  val executor = AsyncExecutor.default("DALSpec")

  val db = new Database(dataSource, executor)

  val h2 = new DAL(H2Driver)
  val sqlite = new DAL(SQLiteDriver)
  val mysql = new DAL(MySQLDriver)

  "H2 driver" should {

    "have a config" in {
      Database.forConfig("h2") must beAnInstanceOf[Database]
    }

    "have a DAL" in {
      h2 must beAnInstanceOf[DAL]
    }

    "be an instance of a database" in {
      db must beAnInstanceOf[Database]
    }

    "create" in { implicit context: ExecutionEnv =>

      val sql1 = """
          |create table "USERS" ("USER_NAME" VARCHAR NOT NULL,
          |"PIC_ID" INTEGER NOT NULL,"USER_ID" INTEGER GENERATED
          | BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY)
          |""".stripMargin.replace("\n", "")
      val sql2 = """
          |create table "PICTURES" ("PIC_URL" VARCHAR NOT NULL,
          |"PIC_ID" INTEGER GENERATED BY DEFAULT AS IDENTITY(START
          | WITH 1) PRIMARY KEY)""".stripMargin.replace("\n", "")

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String)).when(sql1)
        .returns(preparedStatement).once
      (connection.prepareStatement (_: String)).when(sql2)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import h2.driver.api._
        h2.create
      } must beEqualTo((): Unit).await
    }

    "insert user" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String, _: Array[JString]))
        .when("insert into \"PICTURES\" (\"PIC_URL\")  values (?)", *)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import h2.driver.api._
        h2.insert(User("name1", Picture("http://pics/default")))
      } must throwA(new NoSuchElementException("Invoker.first")).await
    }
  }

  "SQLite driver" should {

    "have a config" in {
      Database.forConfig("sqlite") must beAnInstanceOf[Database]
    }

    "have a DAL" in {
      sqlite must beAnInstanceOf[DAL]
    }

    "be an instance of a database" in {
      db must beAnInstanceOf[Database]
    }

    "create" in { implicit context: ExecutionEnv =>

      val sql1 = """create table "USERS" ("USER_NAME" VARCHAR(254)
        | NOT NULL,"PIC_ID" INTEGER NOT NULL,"USER_ID" INTEGER PRIMARY
        | KEY AUTOINCREMENT)""".stripMargin.replace("\n", "")

      val sql2 = """create table "PICTURES" ("PIC_URL" VARCHAR(254)
        | NOT NULL,"PIC_ID" INTEGER PRIMARY KEY AUTOINCREMENT)
        |""".stripMargin.replace("\n", "")

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String)).when(sql1)
        .returns(preparedStatement).once
      (connection.prepareStatement (_: String)).when(sql2)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        sqlite.create
      } must beEqualTo((): Unit).await
    }

    "insert picture" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String, _: Array[JString]))
        .when("insert into \"PICTURES\" (\"PIC_URL\")  values (?)", *)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import sqlite.driver.api._
        sqlite.insert(Picture("http://pics/default"))
      } must throwA(new NoSuchElementException("Invoker.first")).await
    }

    "insert user" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String, _: Array[JString]))
        .when("insert into \"PICTURES\" (\"PIC_URL\")  values (?)", *)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import sqlite.driver.api._
        sqlite.insert(User("name1", Picture("http://pics/default")))
      } must beEqualTo((): Unit).await
    }

    "user results" in { implicit context: ExecutionEnv =>

      val sql = """select "USER_NAME", "PIC_ID", "USER_ID" from "USERS""""

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String))
        .when(sql).returns(preparedStatement).once

      // Run and check the future
      db.run {
        import sqlite.driver.api._
        sqlite.users.result
      } must beEqualTo(List(0)).await
    }

    "picture results" in { implicit context: ExecutionEnv =>

      val sql = """select "PIC_URL", "PIC_ID" from "PICTURES""""

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String))
        .when(sql).returns(preparedStatement).once

      // Run and check the future
      db.run {
        import sqlite.driver.api._
        sqlite.pictures.result
      } must beEqualTo(List(0)).await
    }

  }

  "MySQL driver" should {

    "have a config" in {
      Database.forConfig("mysql") must throwA[ConfigException]
    }

    "have a DAL" in {
      mysql must beAnInstanceOf[DAL]
    }

    "be an instance of a database" in {
      db must beAnInstanceOf[Database]
    }

    "create" in { implicit context: ExecutionEnv =>

      val sql1 = """create table `USERS` (`USER_NAME` TEXT NOT NULL,
        |`PIC_ID` INTEGER NOT NULL,`USER_ID` INTEGER AUTO_INCREMENT
        | PRIMARY KEY)""".stripMargin.replace("\n", "")

      val sql2 = """create table `PICTURES` (`PIC_URL` TEXT NOT NULL,
        |`PIC_ID` INTEGER AUTO_INCREMENT PRIMARY KEY)
        |""".stripMargin.replace("\n", "")

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String))
        .when(sql1).returns(preparedStatement).once
      (connection.prepareStatement (_: String))
        .when(sql2).returns(preparedStatement).once

      // Run and check the future
      db.run {
        mysql.create
      } must beEqualTo((): Unit).await
    }

    "insert picture" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String, _: Array[JString]))
        .when("insert into `PICTURES` (`PIC_URL`)  values (?)", *)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import mysql.driver.api._
        mysql.insert(Picture("http://pics/default"))
      } must throwA(new NoSuchElementException("Invoker.first")).await
    }

    "insert user" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String, _: Array[JString])).
        when("insert into `PICTURES` (`PIC_URL`)  values (?)", *)
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import mysql.driver.api._
        mysql.insert(User("name1", Picture("http://pics/default")))
      } must throwA(new NoSuchElementException("Invoker.first")).await
    }

    "user results" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String))
        .when("select `USER_NAME`, `PIC_ID`, `USER_ID` from `USERS`")
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import mysql.driver.api._
        mysql.users.result
      } must beEqualTo(List(0)).await
    }

    "picture results" in { implicit context: ExecutionEnv =>

      // Configure stubs
      (dataSource.createConnection _).when().returns(connection)
      (connection.prepareStatement (_: String))
        .when("select `PIC_URL`, `PIC_ID` from `PICTURES`")
        .returns(preparedStatement).once

      // Run and check the future
      db.run {
        import mysql.driver.api._
        mysql.pictures.result
      } must beEqualTo(List(0)).await
    }

  }

  def after = {
    Util.unloadDrivers
  }
}
